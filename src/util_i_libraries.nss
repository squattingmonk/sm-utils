/// ----------------------------------------------------------------------------
/// @file   util_i_libraries.nss
/// @author Michael A. Sinclair (Squatting Monk) <squattingmonk@gmail.com>
/// @author Ed Burke (tinygiant98) <af.hog.pilot@gmail.com>
/// @brief  This file holds functions for packing scripts into libraries. This
///     allows the builder to dramatically reduce the module script count by
///     keeping related scripts in the same file.
/// @details
/// Libraries allow the builder to encapsulate many scripts into one,
/// dramatically reducing the script count in the module. In a library, each
/// script is a function bound to a unique name and/or number. When the library
/// is called, the name is routed to the proper function.
///
/// Since each script defined by a library has a unique name to identify it, the
/// builder can execute a library script without having to know the file it is
/// located in. This makes it easy to create script systems to override behavior
/// of another system; you don't have to edit the other system's code, you just
/// implement your own function to override it.
///
/// ## Anatomy of a Library
/// This is an example of a simple library:
///
/// ``` nwscript
/// #include "util_i_libraries"
///
/// void MyFunction()
/// {
///     // ...
/// }
///
/// void MyOtherFunction()
/// {
///     // ...
/// }
///
/// void OnLibraryLoad()
/// {
///     RegisterLibraryScript("MyFunction");
///     RegisterLibraryScript("MyOtherFunction");
/// }
/// ```
///
/// This script contains custom functions (`MyFunction()` and `MyOtherFunction()`)
/// as well as an `OnLibraryLoad()` function. `OnLibraryLoad()` is executed
/// whenever the library is loaded by `LoadLibrary()`; it calls
/// `RegisterLibraryScript()` to expose the names of the custom functions as
/// library scripts. When a library script is called with `RunLibraryScript()`,
/// the custom functions are called.
///
/// If you want to do something more complicated that can't be handled by a
/// single function call, you can pass a unique number to
/// `RegisterLibraryScript()` as its second parameter, which will cause
/// `RunLibraryScript()` to call a special customizable dispatching function
/// called `OnLibraryScript()`. This function takes the name and number of the
/// desired function and executes the desired code. For example:
///
/// ``` nwscript
/// #include "util_i_libraries"
///
/// void OnLibraryLoad()
/// {
///     RegisterLibraryScript("Give50GP",  1);
///     RegisterLibraryScript("Give100GP", 2);
/// }
///
/// void OnLibraryScript(string sScript, int nEntry)
/// {
///     switch (nEntry)
///     {
///         case 1: GiveGoldToCreature(OBJECT_SELF, 50); break;
///         case 2: GiveGoldToCreature(OBJECT_SELF, 100); break;
///     }
/// }
/// ```
///
/// **Note:** A library does not need to have a `main()` function, because this
/// will be automatically generated by the `LoadLibrary()` and
/// `RunLibraryScript()` functions.
///
/// ## Using a Library
/// `util_i_libraries.nss` is needed to load or run library scripts.
///
/// To use a library, you must first load it. This will activate the library's
/// `OnLibraryLoad()` function and register each desired function.
///
/// ``` nwscript
/// // Loads a single library
/// LoadLibrary("my_l_library");
///
/// // Loads a CSV list of library scripts
/// LoadLibraries("pw_l_plugin, dlg_l_example, prr_l_main");
///
/// // Loads all libraries matching a glob pattern
/// LoadLibrariesByPattern("*_l_*");
///
/// // Loads all libraries matching a prefix
/// LoadLibrariesByPrefix("pw_l_");
/// ```
///
/// If a library implements a script that has already been implemented in
/// another library, a warning will be issued and the newer script will take
/// precedence.
///
/// Calling a library script is done using `RunLibraryScript()`. The name
/// supplied should be the name bound to the function in the library's
/// `OnLibraryLoad()`. If the name supplied is implemented by a library, the
/// library will be JIT compiled and the desired function will be called with
/// `ExecuteScriptChunk()`. Otherwise, the name will be assumed to match a
/// normal script, which will be executed with `ExecuteScript()`.
///
/// ``` nwscript
/// // Executes a single library script on OBJECT_SELF
/// RunLibraryScript("MyFunction");
///
/// // Executes a CSV list of library scripts, for which oPC will be OBJECT_SELF
/// object oPC = GetFirstPC();
/// RunLibraryScripts("MyFunction, MyOtherFunction", oPC);
/// ```
///
/// ## Pre-Compiled Libraries
/// By default, libraries are run using `ExecuteScriptChunk()`, which JIT
/// compiles the script and runs it each time the library script is called. If
/// you wish to have your script pre-compiled, you can include the script
/// `util_i_library.nss` in your file in place of `util_i_libraries.nss`. This
/// script contains a `main()` function that will call either your
/// `OnLibraryLoad()` or `OnLibraryScript()` function as appropriate; thus, if
/// you use this method, you *must* provide an `OnLibraryScript()` dispatch
/// function.
///
/// **Note**: `util_i_library.nss` uses the nwnsc `default_function` pragma to
/// prevent compilation errors and will not compile with the toolset compiler.
/// If this is not desired, you can either comment those lines out or implement
/// the `main()` function yourself.
/// ----------------------------------------------------------------------------

#include "util_i_debug"
#include "util_i_csvlists"
#include "util_i_sqlite"
#include "util_i_nss"
#include "util_i_matching"

// -----------------------------------------------------------------------------
//                                   Constants
// -----------------------------------------------------------------------------

const string LIB_RETURN  = "LIB_RETURN";  ///< The return value of the library
const string LIB_LIBRARY = "LIB_LIBRARY"; ///< The library being processed
const string LIB_SCRIPT  = "LIB_SCRIPT";  ///< The library script name
const string LIB_ENTRY   = "LIB_ENTRY";   ///< The library script entry number

// -----------------------------------------------------------------------------
//                              Function Prototypes
// -----------------------------------------------------------------------------

/// @brief Create a library table in the module's volatile sqlite database.
/// @param bReset if TRUE, the table will be dropped if already present.
/// @note This is called automatically by the library functions.
void CreateLibraryTable(int bReset = FALSE);

/// @brief Add a database record associating a script with a library.
/// @param sLibrary The script to source from.
/// @param sScript The name to associate with the library script.
/// @param nEntry A number unique to sLibrary to identify this script. If this
///     is 0 and the library has not been pre-compiled, RunLibraryScript() will
///     call sScript directly. Otherwise, RunLibraryScript() will run a dispatch
///     function that can use this number to execute the correct code. Thus,
///     nEntry must be set if sScript does not exactly match the desired
///     function name or the function requires parameters.
/// @param sFilename Unique filename for the compiled ncs file.
void AddLibraryScript(string sLibrary, string sScript, int nEntry = 0, string sFilename = "");

/// @brief Remove database records associated with a library.
/// @param sLibrary The library to remove.
/// @note If sLibrary is associated with pre-compiled ncs files, the ncs
///     files will not be deleted from the `currentgame` folder; however
///     these files will no longer be referenced and will be deleted with the
///     module is shutdown.
void RemoveLibraryScripts(string sLibrary);

/// @brief Return the name of the library containing a script from the database.
/// @param sScript The name of the library script.
string GetScriptLibrary(string sScript);

/// @brief Return the entry number associated with a library script.
/// @param sScript The name of the library script.
int GetScriptEntry(string sScript);

/// @brief Return the filename of the pre-compiled script from the database.
/// @param sScript The name of the library script.
string GetScriptFilename(string sScript);

/// @brief Return a prepared query with the with the library and entry data
///     associated with a library script.
/// @param sScript The name of the library script.
/// @note This allows users to retrive the same data returned by
///     GetScriptLibrary() and GetScriptEntry() with one function.
sqlquery GetScriptData(string sScript);

/// @brief Return whether a script library has been loaded.
/// @param sLibrary The name of the script library file.
int GetIsLibraryLoaded(string sLibrary);

/// @brief Load a script library by executing its OnLibraryLoad() function.
/// @param sLibrary The name of the script library file.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
void LoadLibrary(string sLibrary, int bForce = FALSE);

/// @brief Load a list of script libraries in sequence.
/// @param sLibraries A CSV list of libraries to load.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
void LoadLibraries(string sLibraries, int bForce = FALSE);

/// @brief Return a json array of script names with a prefix.
/// @param sPrefix The prefix matching the scripts to find.
/// @returns A sorted json array of script names, minus the extensions.
/// @note The search includes both nss and ncs files, with duplicates removed.
json GetScriptsByPrefix(string sPrefix);

/// @brief Load all scripts matching the given glob pattern(s).
/// @param sPattern A CSV list of glob patterns to match with. Supported syntax:
///     - `*`: match zero or more characters
///     - `?`: match a single character
///     - `[abc]`: match any of a, b, or c
///     - `[a-z]`: match any character from a-z
///     - other text is matched literally
/// @param bForce If TRUE, will-reload the library if it was already loaded.
void LoadLibrariesByPattern(string sPattern, int bForce = FALSE);

/// @brief Load all scripts with a given prefix as script libraries.
/// @param sPrefix A prefix for the desired script libraries.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
/// @see GetMatchesPattern() for the rules on glob syntax.
void LoadLibrariesByPrefix(string sPrefix, int bForce = FALSE);

/// @brief Compile a script library by compiling individual functions into
///     ncs files.
/// @param sLibrary The name of the script library file.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
/// @warning sLibrary cannot have a `void main()` function.
void CompileLibrary(string sLibrary, int bForce = FALSE);

/// @brief Compile a list of script libraries in sequence.
/// @param sLibraries A CSV list of libraries to compile.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
/// @warning File in sLibraries cannot have a `void main()` function.
void CompileLibraries(string sLibraries, int bForce = FALSE);

/// @brief Compile all scripts matching the given glob pattern(s).
/// @param sPattern A CSV list of glob patterns to match with. Supported syntax:
///     - `*`: match zero or more characters
///     - `?`: match a single character
///     - `[abc]`: match any of a, b, or c
///     - `[a-z]`: match any character from a-z
///     - other text is matched literally
/// @param bForce If TRUE, will-reload the library if it was already loaded.
/// @warning Files matching sPattern cannot have a `void main()` function.
void CompileLibrariesByPattern(string sPattern, int bForce = FALSE);

/// @brief Compile all scripts with a given prefix as script libraries.
/// @param sPrefix A prefix for the desired script libraries.
/// @param bForce If TRUE, will re-load the library if it was already loaded.
/// @see GetMatchesPattern() for the rules on glob syntax.
/// @warning Files matching sPrefix cannot have a `void main()` function.
void CompileLibrariesByPrefix(string sPrefix, int bForce = FALSE);

/// @brief Execute a registered library script.
/// @param sScript The unique name of the library script.
/// @param oSelf The object that should execute the script as OBJECT_SELF.
/// @returns The integer value set with LibraryReturn() by sScript.
/// @note If sScript is not registered as a library script, it will be executed
///     as a regular script instead.
int RunLibraryScript(string sScript, object oSelf = OBJECT_SELF);

/// @brief Execute a list of registered library scripts in sequence.
/// @param sScripts A CSV list of library script names.
/// @param oSelf The object that should execute the scripts as OBJECT_SELF.
/// @note If any script in sScripts is not registered as a library script, it
///     will be executed as a regular script instead.
void RunLibraryScripts(string sScripts, object oSelf = OBJECT_SELF);

/// @brief Register a script to a library. The script can later be called using
///     RunLibraryScript().
/// @param sScript A name for the script. Must be unique in the module. If a
///     second script with the same name is registered, it will overwrite the
///     first one.  This value does not have to match the function or script name.
/// @param nEntry A number unique to this library to identify this script. If
///     this is 0 and the library has not been pre-compiled, RunLibraryScript()
///     will call sScript directly. Otherwise, RunLibraryScript() will run a
///     dispatch function that can use this number to execute the correct code.
///     Thus, nEntry must be set if sScript does not exactly match the desired
///     function name or the function requires parameters.
/// @note Must be called within a script library's OnLibraryLoad() function. For
///     uses in other places, use AddLibraryScript().
void RegisterLibraryScript(string sScript, int nEntry = 0);

/// @brief Compile a single library script function into an ncs file for the 
///     current module session.
/// @param sScript A name for the script. Must be unique in the module. If a
///     second script with the same name is registered, it will overwrite the
///     first one.  Unlike `RegisterLibraryScript()`, this value must match
///     the function's name.
/// @param nEntry A number unique to this library to identify this script. This
///     number should be unique to the library, however this number is not used
///     unless the resultant ncs file is not found when `RunLibraryScript()` is
///     executed against it.  If the matching ncs file is found,
///     `OnLibraryScript()` is not called and the ncs file is executed directly.
void CompileLibraryScript(string sScript, int nEntry = 0);

/// @brief Set the return value of the currently executing library script.
/// @param nValue The value to return to the calling script.
void LibraryReturn(int nValue);

/// @brief Broadcast a library execution error.  This function is meant to be
///     called from a library's `OnLibraryScript()` function when a called
///     function is not found.
/// @param sFile The library script's filename, usually passed with __FILE__.
/// @param sScript Name of the script called for execution.
/// @param nEntry Entry number of the script called for execution.
void LibraryError(string sFile, string sScript, int nEntry);

// -----------------------------------------------------------------------------
//                             Function Definitions
// -----------------------------------------------------------------------------

void CreateLibraryTable(int bReset = FALSE)
{
    SqlCreateTableModule("library_scripts", r"
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sLibrary TEXT NOT NULL,
        sScript TEXT NOT NULL UNIQUE ON CONFLICT REPLACE,
        nEntry INTEGER NOT NULL,
        sFilename TEXT NOT NULL
    ", bReset);
}

void AddLibraryScript(string sLibrary, string sScript, int nEntry = 0, string sFilename = "")
{
    CreateLibraryTable();

    Debug("Adding" + (sFilename != "" ? " pre-compiled " : " ") + "library function " +
        sScript + " to library " + sLibrary + " at entry " + IntToString(nEntry));

    string sQuery = r"
        INSERT INTO library_scripts (sLibrary, sScript, nEntry, sFilename) 
        VALUES (@sLibrary, @sScript, @nEntry, @sFilename);
    ";
    sqlquery sql = SqlPrepareQueryModule(sQuery);
    SqlBindString(sql, "@sLibrary", sLibrary);
    SqlBindString(sql, "@sScript", sScript);
    SqlBindInt(sql, "@nEntry", nEntry);
    SqlBindString(sql, "@sFilename", sFilename);

    SqlStep(sql);
}

void RemoveLibraryScripts(string sLibrary)
{
    CreateLibraryTable();

    Debug("Removing library functions from library " + sLibrary);

    string sQuery = r"
        DELETE FROM script_libraries
        WHERE sLibrary = @sLibrary;
    ";
    sqlquery sql = SqlPrepareQueryModule(sQuery);
    SqlBindString(sql, "@sLibrary", sLibrary);
    SqlStep(sql);
}

string GetScriptFieldData(string sField, string sScript)
{
    CreateLibraryTable();

    string sQuery = r"
        SELECT $1 FROM library_scripts
        WHERE sScript = @sScript;
    ";
    sQuery = SubstituteSubString(sQuery, "$1", sField);
    sqlquery sql = SqlPrepareQueryModule(sQuery);
    SqlBindString(sql, "@sScript", sScript);

    return SqlStep(sql) ? SqlGetString(sql, 0) : "";
}

string GetScriptLibrary(string sScript)
{
    return GetScriptFieldData("sLibrary", sScript);
}

int GetScriptEntry(string sScript)
{
    return StringToInt(GetScriptFieldData("nEntry", sScript));
}

string GetScriptFilename(string sScript)
{
    return GetScriptFieldData("sFilename", sScript);
}

sqlquery GetScriptData(string sScript)
{
    CreateLibraryTable();

    string sQuery = r"
        SELECT sLibrary, nEntry, sFilename
        FROM library_scripts
        WHERE sScript = @sScript;
    ";
    sqlquery sql = SqlPrepareQueryModule(sQuery);
    SqlBindString(sql, "@sScript", sScript);

    return sql;
}

int GetIsLibraryLoaded(string sLibrary)
{
    CreateLibraryTable();

    string sQuery = r"
        SELECT COUNT(sLibrary)
        FROM library_scripts
        WHERE sLibrary = @sLibrary
            LIMIT 1;
    ";
    sqlquery sql = SqlPrepareQueryModule(sQuery);
    SqlBindString(sql, "@sLibrary", sLibrary);

    return SqlStep(sql) ? SqlGetInt(sql, 0) : FALSE;
}

void LoadLibrary(string sLibrary, int bForce = FALSE)
{
    Debug("Attempting to " + (bForce ? "force " : "") + "load library " + sLibrary);

    if (bForce || !GetIsLibraryLoaded(sLibrary))
    {
        SetScriptParam(LIB_LIBRARY, sLibrary);
        if (ResManGetAliasFor(sLibrary, RESTYPE_NCS) == "")
        {
            Debug(sLibrary + ".ncs not present; loading library as chunk");
            string sChunk = NssInclude(sLibrary) + NssVoidMain(NssFunction("OnLibraryLoad"));
            string sError = ExecuteScriptChunk(sChunk, GetModule(), FALSE);
            if (sError != "")
                CriticalError("Could not load " + sLibrary + ": " + sError);
        }
        else
            ExecuteScript(sLibrary, GetModule());

    }
    else
        Error("Library " + sLibrary + " already loaded!");
}

void LoadLibraries(string sLibraries, int bForce = FALSE)
{
    Debug("Attempting to " + (bForce ? "force " : "") + "load libraries " + sLibraries);

    int i, nCount = CountList(sLibraries);
    for (i = 0; i < nCount; i++)
        LoadLibrary(GetListItem(sLibraries, i), bForce);
}

/// @private Supports GetScriptsByPrefix*(). Adds all scripts of nResType
// matching a prefix to a json array and returns it.
json _GetScriptsByPrefix(json jArray, string sPrefix, int nResType)
{
    int i;
    string sScript;
    while ((sScript = ResManFindPrefix(sPrefix, nResType, ++i)) != "")
        jArray = JsonArrayInsert(jArray, JsonString(sScript));

    return jArray;
}

json GetScriptsByPrefix(string sPrefix)
{
    json jScripts = _GetScriptsByPrefix(JsonArray(), sPrefix, RESTYPE_NCS);
         jScripts = _GetScriptsByPrefix(jScripts,    sPrefix, RESTYPE_NSS);
         jScripts = JsonArrayTransform(jScripts, JSON_ARRAY_UNIQUE);
         jScripts = JsonArrayTransform(jScripts, JSON_ARRAY_SORT_ASCENDING);
    return jScripts;
}

void LoadLibrariesByPattern(string sPatterns, int bForce = FALSE)
{
    if (sPatterns == "")
        return;

    Debug("Loading libraries matching \"" + sPatterns + "\"");
    json jPatterns  = ListToJson(sPatterns);
    json jLibraries = FilterByPatterns(GetScriptsByPrefix(""), jPatterns, TRUE);
    LoadLibraries(JsonToList(jLibraries), bForce);
}

void LoadLibrariesByPrefix(string sPrefix, int bForce = FALSE)
{
    Debug("Loading libraries with prefix \"" + sPrefix + "\"");
    json jLibraries = GetScriptsByPrefix(sPrefix);
    LoadLibraries(JsonToList(jLibraries), bForce);
}

void LoadPrefixLibraries(string sPrefix, int bForce = FALSE)
{
    Debug("LoadPrefixLibraries() is deprecated; use LoadLibrariesByPrefix()");
    LoadLibrariesByPrefix(sPrefix, bForce);
}

/// @private Compile an individual function into an ncs file in the `currentgame`
///     folder.  `OnLibraryLoad` and `OnLibraryScript` will be excluded, therefore
///     legacy libraries can be updated with a call to `CompileLibrary(__FILE__);`
///     or `CompileLibraryScript(<script>, <entry>);`.
/// @return FALSE if script compilation failed.
int _CompileFunction(string sLibrary, string sFunction, int nEntry)
{
    string sExclusions = "OnLibraryLoad,OnLibraryScript";
    if (HasListItem(sExclusions, sFunction))
    {
        Error("Skippnig function " + sFunction + " compilation for library " +
            sLibrary + "; function name is excluded");
        return TRUE;
    }

    string sChunk = r"
        #include ""$1"" void main() {$2();}
    ";
    sChunk = SubstituteSubString(sChunk, "$1", sLibrary);
    sChunk = SubstituteSubString(sChunk, "$2", sFunction);

    string sFilename;
    do {
        sFilename = GetSubString(RegExpReplace("-", GetRandomUUID(), ""), 0, 16);
    } while (ResManGetAliasFor(sFilename, RESTYPE_NCS) != "");

    string sError = CompileScript(sFilename, sChunk);
    if (sError == "" && ResManGetAliasFor(sFilename, RESTYPE_NCS) != "")
        AddLibraryScript(sLibrary, sFunction, nEntry, sFilename);
    else
        Error("Unable to compile library script:" +
            "\n  Library: " + sLibrary +
            "\n  Script: " + sFunction +
            "\n  Error: " + sError);

    return sError == "";
}

void CompileLibrary(string sLibrary, int bForce = FALSE)
{
    sLibrary = RegExpReplace("\\.nss$", sLibrary, "");
    
    Debug("Attempting to " + (bForce ? "force " : "") + "load and compile library " + sLibrary);

    if (bForce || !GetIsLibraryLoaded(sLibrary))
    {
        if (ResManGetAliasFor(sLibrary, RESTYPE_NSS) == "")
            Debug(sLibrary + ".nss not present; unable to load and compile library");
        else
        {
            string sScript = ResManGetFileContents(sLibrary, RESTYPE_NSS);
            sScript = RegExpReplace("\\/\\/.*?$|\\/\\*[\\s\\S]*?\\*\\/", sScript, "");

            string r = "void|int|float|string|object|vector|effect|event|location|talent|itemproperty|sqlquery|cassowary|json";
            r = "\\b(?:" + r + ")\\s+(\\w+)\\s*\\([^)]*\\)\\s*[^;]";

            json j = RegExpIterate(r, sScript);
            int n; for (; n < JsonGetLength(j); n++)
            {
                string sFunction = JsonGetString(JsonArrayGet(JsonArrayGet(j, n), 1));
                if (!_CompileFunction(sLibrary, sFunction, n))
                    return;
            }
        }
    }
    else
        Error("Library " + sLibrary + " already loaded!");
}

void CompileLibraries(string sLibraries, int bForce = FALSE)
{
    Debug("Attempting to " + (bForce ? "force " : "") + "load and compile libraries " + sLibraries);

    int i, nCount = CountList(sLibraries);
    for (i = 0; i < nCount; i++)
        CompileLibrary(GetListItem(sLibraries, i), bForce);
}

void CompileLibrariesByPattern(string sPatterns, int bForce = FALSE)
{
    if (sPatterns == "")
        return;

    Debug("Compiling libraries matching \"" + sPatterns + "\"");
    json jPatterns  = ListToJson(sPatterns);
    json jLibraries = FilterByPatterns(GetScriptsByPrefix(""), jPatterns, TRUE);
    CompileLibraries(JsonToList(jLibraries), bForce);
}

void CompileLibrariesByPrefix(string sPrefix, int bForce = FALSE)
{
    Debug("Compiling libraries with prefix \"" + sPrefix + "\"");
    json jLibraries = GetScriptsByPrefix(sPrefix);
    CompileLibraries(JsonToList(jLibraries), bForce);
}

int RunLibraryScript(string sScript, object oSelf = OBJECT_SELF)
{
    if (sScript == "") return -1;

    string sLibrary, sFilename;
    int nEntry;

    sqlquery sqlScriptData = GetScriptData(sScript);
    if (SqlStep(sqlScriptData))
    {
        sLibrary = SqlGetString(sqlScriptData, 0);
        nEntry = SqlGetInt(sqlScriptData, 1);
        sFilename = SqlGetString(sqlScriptData, 2);
    }

    DeleteLocalInt(oSelf, LIB_RETURN);

    if (sLibrary != "")
    {
        Debug((sFilename != "" ? "Pre-compiled " : "") + "Library script " + sScript +
            " found in " + sLibrary + (nEntry != 0 ? " at entry " + IntToString(nEntry) : ""));

        SetScriptParam(LIB_LIBRARY, sLibrary);
        SetScriptParam(LIB_SCRIPT, sScript);
        SetScriptParam(LIB_ENTRY, IntToString(nEntry));

        if (sFilename != "")
            ExecuteScript(sFilename, oSelf);
        else if (ResManGetAliasFor(sLibrary, RESTYPE_NCS) == "")
        {
            Debug(sLibrary + ".ncs not present; running library script as chunk");
            string sChunk = NssInclude(sLibrary) + NssVoidMain(nEntry ?
                NssFunction("OnLibraryScript", NssQuote(sScript) + ", " + IntToString(nEntry)) :
                NssFunction(sScript));
            string sError = ExecuteScriptChunk(sChunk, oSelf, FALSE);
            if (sError != "")
                CriticalError("RunLibraryScript(" + sScript +") failed: " + sError);
        }
        else
            ExecuteScript(sLibrary, oSelf);
    }
    else
    {
        Debug(sScript + " is not a library script; executing directly");
        ExecuteScript(sScript, oSelf);
    }

    return GetLocalInt(oSelf, LIB_RETURN);
}

void RunLibraryScripts(string sScripts, object oSelf = OBJECT_SELF)
{
    int i, nCount = CountList(sScripts);
    for (i = 0; i < nCount; i++)
        RunLibraryScript(GetListItem(sScripts, i), oSelf);
}

void RegisterLibraryScript(string sScript, int nEntry = 0)
{
    string sLibrary = GetScriptParam(LIB_LIBRARY);
    string sExist = GetScriptLibrary(sScript);

    if (sLibrary != sExist && sExist != "")
        Warning(sLibrary + " is overriding " + sExist + "'s implementation of " + sScript);

    int nOldEntry = GetScriptEntry(sScript);
    if (nOldEntry)
        Warning(sLibrary + " already declared " + sScript +
            " Old Entry: " + IntToString(nOldEntry) +
            " New Entry: " + IntToString(nEntry));

    AddLibraryScript(sLibrary, sScript, nEntry);
}

void CompileLibraryScript(string sScript, int nEntry = 0)
{
    string sLibrary = GetScriptParam(LIB_LIBRARY);
    string sExist = GetScriptLibrary(sScript);

    if (sLibrary != sExist && sExist != "")
        Warning(sLibrary + " is overriding " + sExist + "'s implementation of " + sScript);

    int nOldEntry = GetScriptEntry(sScript);
    if (nOldEntry)
        Warning(sLibrary + " already declared " + sScript +
            " Old Entry: " + IntToString(nOldEntry) +
            " New Entry: " + IntToString(nEntry));
    
    string sFilename = GetScriptFilename(sScript);
    if (sFilename != "" && ResManGetAliasFor(sFilename, RESTYPE_NCS) != "")
        Warning(sScript + " previously compiled as " + sFilename + ".ncs; " +
            "file will be abandoned");

    _CompileFunction(sLibrary, sScript, nEntry);
}

void LibraryReturn(int nValue)
{
    SetLocalInt(OBJECT_SELF, LIB_RETURN, nValue);
}

void LibraryError(string sFile, string sScript, int nEntry)
{
    string sLibrary = GetScriptLibrary(sScript);

    Error("Library script execution error in " + sFile + "; " +
        "script request not handled or found by `OnLibraryScript`: " + 
        (sLibrary == "" ? "(Unknown Library)" : sLibrary) + "::" +
        sScript + "(" + IntToString(nEntry) + ")");
}
